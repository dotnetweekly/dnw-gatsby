<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Sat, 09 May 2020 07:09:40 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <item>
            <title><![CDATA[Configuring Azure Services and emulators using Visual Studio]]></title>
            <link>https://www.dotnetweekly.com/articles/configuring-azure-services-and-emulators-using-visual-studio</link>
            <guid>https://www.dotnetweekly.com/articles/configuring-azure-services-and-emulators-using-visual-studio</guid>
            <pubDate>Fri, 08 May 2020 02:43:26 GMT</pubDate>
            <content:encoded><![CDATA[Starting with Visual Studio 16.6 Preview 2 the Connected Services tab offers a new experience called Service Dependencies. You can use it to connect your app to Azure services such as Azure SQL, Storage, Key Vault and many others. Wherever possible local emulation options are also available and more are planned for the future.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Breaking The Relational Model]]></title>
            <link>https://www.dotnetweekly.com/articles/breaking-the-relational-model</link>
            <guid>https://www.dotnetweekly.com/articles/breaking-the-relational-model</guid>
            <pubDate>Fri, 08 May 2020 02:42:03 GMT</pubDate>
            <content:encoded><![CDATA[The rule: Normalize until it hurts; denormalize until it works. That’s what you typically get taught early on. While normalizing a database is a solid practice and something you should do when designing a system; it can jump up and bite you when you get under load. You probably won’t deal with most of these issues early on in a system (and shouldn’t), but the time will come where eventually some degree of denormalization is necessary to keep performance up to snuff.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[.NET Portability Analyzer]]></title>
            <link>https://www.dotnetweekly.com/articles/net-portability-analyzer</link>
            <guid>https://www.dotnetweekly.com/articles/net-portability-analyzer</guid>
            <pubDate>Fri, 08 May 2020 02:40:43 GMT</pubDate>
            <content:encoded><![CDATA[In order to migrate your application from .NET Framework to .NET Core, one part of the migration is making sure your existing code that targets the .NET Framework BCL (Base Class Library) also works with the .NET Core BCL. This is where the .NET Portability Analyzer comes in.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Using ML.NET for deep learning on images in Azure]]></title>
            <link>https://www.dotnetweekly.com/articles/using-mlnet-for-deep-learning-on-images-in-azure</link>
            <guid>https://www.dotnetweekly.com/articles/using-mlnet-for-deep-learning-on-images-in-azure</guid>
            <pubDate>Fri, 08 May 2020 02:40:09 GMT</pubDate>
            <content:encoded><![CDATA[In March 2020, ML.NET added support for training Image Classification models in Azure. Although the image classification scenario was released in late 2019, users were limited by the resources on their local compute environments. Training in Azure enables users to scale image classification scenarios by using GPU optimized Linux virtual machines.

This post will show how to train a custom image classification model in Azure to categorize flowers using ML.NET Model Builder. Then, you can leverage your existing .NET skills to consume the trained model inside a C# .NET Core console application. Best of all, little to no prior machine learning knowledge is required. Let’s get started!]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Configure a domain for an Azure App Service using Cloudflare]]></title>
            <link>https://www.dotnetweekly.com/articles/configure-a-domain-for-an-azure-app-service-using-cloudflare</link>
            <guid>https://www.dotnetweekly.com/articles/configure-a-domain-for-an-azure-app-service-using-cloudflare</guid>
            <pubDate>Fri, 08 May 2020 01:28:00 GMT</pubDate>
            <content:encoded><![CDATA[This blog shows how to create an Azure App Service with a custom domain using Cloudflare to configure the domain name servers. The post used the following blog from Matteo for the original setup: Serving your Azure App Service under your custom domain

To create a custom domain for an Azure App Service, you require three things:

A domain which maps to a domain name server
TXT, A records for the root domain, CNAME records for sub domains
A hosting service to host the application which maps to the A, TXT, CNAME records.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azure Charts Visualize your cloud learning journey]]></title>
            <link>https://www.dotnetweekly.com/articles/azure-charts-visualize-your-cloud-learning-journey</link>
            <guid>https://www.dotnetweekly.com/articles/azure-charts-visualize-your-cloud-learning-journey</guid>
            <pubDate>Fri, 08 May 2020 01:27:16 GMT</pubDate>
            <content:encoded><![CDATA[Are you just starting your cloud journey or looking for ways to upgrade your knowledge in specific areas?Azure Charts is a web based application which allows you to see what the Azure consists of and how it evolves. Additionally, to help you learn Azure in a focused way and stay up-to-date in your knowledge, there is a suite of interactive charts introduced recently which you can find under the Learning menu in the navigation bar. The learning menus utilize the Microsoft Learn Catalog API 

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Messaging with Azure Service Bus - Part 7 - Topics and Subscriptions]]></title>
            <link>https://www.dotnetweekly.com/articles/messaging-with-azure-service-bus-part-7-topics-and-subscriptions</link>
            <guid>https://www.dotnetweekly.com/articles/messaging-with-azure-service-bus-part-7-topics-and-subscriptions</guid>
            <pubDate>Fri, 08 May 2020 01:26:39 GMT</pubDate>
            <content:encoded><![CDATA[Part 1 - Why Use Messaging?
Part 2 - The Challenges of Messaging
Part 3 - Introducing Azure Service Bus
Part 4 - Sending and Receiving Messages
Part 5 - Message Sending Options
Part 6 - Message Receiving Options
Part 7 - Topics and Subscriptions]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dynamic Routing in ASP.NET Core 3]]></title>
            <link>https://www.dotnetweekly.com/articles/dynamic-routing-in-aspnet-core-3</link>
            <guid>https://www.dotnetweekly.com/articles/dynamic-routing-in-aspnet-core-3</guid>
            <pubDate>Fri, 08 May 2020 01:26:09 GMT</pubDate>
            <content:encoded><![CDATA[ASP.NET Core 3 introduced a not so talked about feature which is dynamic routing. In a nutshell, it means that it is possible to decide at runtime the controller, action and route tokens that a request will be dispatched to. The idea is to map a route pattern to a dynamic route handler, like this:

app.UseEndpoints(endpoints =>
{
    endpoints.MapDynamicControllerRoute<SearchValueTransformer>("search/{**product}");
});]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[C# Source Generators: Less Boilerplate Code, More Productivity]]></title>
            <link>https://www.dotnetweekly.com/articles/c-source-generators-less-boilerplate-code-more-productivity</link>
            <guid>https://www.dotnetweekly.com/articles/c-source-generators-less-boilerplate-code-more-productivity</guid>
            <pubDate>Fri, 08 May 2020 01:25:31 GMT</pubDate>
            <content:encoded><![CDATA[One exciting feature of the upcoming .NET 5 are Source Generators.

Source Generators as the name suggests generate C# source code as part of the compilation process. Code generation is not a new concept in Visual Studio and .NET – for example T4 templates have been around for a while now and enable you to programmatically generate/transform content that can be compiled. There are also techniques such as IL Weaving that tools such as Fody use to manipulate the assembly that is produced from the compilation process.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[C# String and Formatting Tips]]></title>
            <link>https://www.dotnetweekly.com/articles/c-string-and-formatting-tips</link>
            <guid>https://www.dotnetweekly.com/articles/c-string-and-formatting-tips</guid>
            <pubDate>Thu, 07 May 2020 15:38:17 GMT</pubDate>
            <content:encoded><![CDATA[In this article, we’re going to be learning about a whole host of different tips and tricks related to C# String and Formatting.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BlazorMiner - a turn-based multiplayer MineSweeper in Blazor]]></title>
            <link>https://www.dotnetweekly.com/articles/blazorminer-a-turn-based-multiplayer-minesweeper-in-blazor</link>
            <guid>https://www.dotnetweekly.com/articles/blazorminer-a-turn-based-multiplayer-minesweeper-in-blazor</guid>
            <pubDate>Thu, 07 May 2020 11:52:45 GMT</pubDate>
            <content:encoded><![CDATA[The project in its completed state is a real-time game that uses ASP.NET Core frameworks Blazor WebAssembly, Web API, Identity, SignalR and Entity Framework Core. All used software are free to use, and all code written is based on open source software mainly made available by Microsoft.

The goal of this project to get an "in-depth, deep-dive overview" of the above frameworks, primarily intended for people who are at least a little familiar with the .NET ecosystem. Unless high demand requires it, not much explanation will be added to the steps required, as the primary documentation by Microsoft is the best place to learn these technologies. This project focuses on dipping your toes into each of these technologies, focusing on the latest and greatest of them all, Blazor. At the time of writing, Blazor WebAssembly is in public preview for ASP.NET Core 3.1 (version 3.2.0-rc1.20223.4) with the production ready version coming in the following weeks. The project can be completed at a steady pace in about 90-120 minutes. Obviously, the project is not a production ready application, has bugs, anomalies and is rough around the edges, but feel free to view the current issues, open a new issue, fork or send me a pull request if you so desire, as any community interaction is most welcome.

We are going to create a game that is similar to Microsoft Minesweeper, but instead of marking and avoiding spots which contain mines, you collect treasure in their place in a multiplayer, turn-based setting.

For the full tutorial, go to https://github.com/yugabe/BlazorMiner ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Strategy Pattern Implementation with Typescript and Angular]]></title>
            <link>https://www.dotnetweekly.com/articles/strategy-pattern-implementation-with-typescript-and-angular</link>
            <guid>https://www.dotnetweekly.com/articles/strategy-pattern-implementation-with-typescript-and-angular</guid>
            <pubDate>Tue, 05 May 2020 10:14:27 GMT</pubDate>
            <content:encoded><![CDATA[In this post, we investigate what strategy design pattern is, how it is implemented in TypeScript, and when it is a good idea to employ it. We will also see some examples in Angular.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CQRS]]></title>
            <link>https://www.dotnetweekly.com/articles/cqrs</link>
            <guid>https://www.dotnetweekly.com/articles/cqrs</guid>
            <pubDate>Tue, 05 May 2020 05:37:10 GMT</pubDate>
            <content:encoded><![CDATA[CQRS is a simple pattern that strictly segregates the responsibility of handling command input into an autonomous system from the responsibility of handling side-effect-free query/read access on the same system. In this article, you will learn exactly what CQRS is, the principles behind it, and the benefits it can provide for your project.

We will see a detailed, step-by-step process of implementing this pattern in practice using a sample project we’ll be working on. This project will be close to what you can see in the real world, and I will explain each step on the way to implement CQRS in great detail.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Top 10 books every .NET/C# developer should read]]></title>
            <link>https://www.dotnetweekly.com/articles/top-10-books-every-net-c-developer-should-read</link>
            <guid>https://www.dotnetweekly.com/articles/top-10-books-every-net-c-developer-should-read</guid>
            <pubDate>Tue, 05 May 2020 05:27:55 GMT</pubDate>
            <content:encoded><![CDATA[Check out my top 10 list of books that I have either enjoyed reading myself or got recommended by developers friends and plan to read.]]></content:encoded>
        </item>
    </channel>
</rss>