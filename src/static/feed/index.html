<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Mon, 30 Nov 2020 02:40:14 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <item>
            <title><![CDATA[The Ultimate Guide to JWT client side auth (Stop using local storage)]]></title>
            <link>https://www.dotnetweekly.com/articles/the-ultimate-guide-to-jwt-client-side-auth-stop-using-local-storage</link>
            <guid>https://www.dotnetweekly.com/articles/the-ultimate-guide-to-jwt-client-side-auth-stop-using-local-storage</guid>
            <pubDate>Mon, 30 Nov 2020 02:37:55 GMT</pubDate>
            <content:encoded><![CDATA[Hello, my name is Kati Frantz, and thank you so much for checking out this tutorial. I want to talk about how to handle JWTs effectively and securely on the client-side.

The most popular practice in the industry today is to save your JWT in a cookie or local storage. I've done this for a couple of years, and I have even taught others to do the same, but I didn't think it was a big deal until one of the applications I worked on was hacked.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JWT with ASP.NET Core in 3 Simple Steps - WebAPI | REST API | Ep 8]]></title>
            <link>https://www.dotnetweekly.com/articles/jwt-with-aspnet-core-in-3-simple-steps-webapi-rest-api-ep-8</link>
            <guid>https://www.dotnetweekly.com/articles/jwt-with-aspnet-core-in-3-simple-steps-webapi-rest-api-ep-8</guid>
            <pubDate>Mon, 30 Nov 2020 02:36:42 GMT</pubDate>
            <content:encoded><![CDATA[Learn to create a JWT Token (JSON Web Token) authentication / authorization with ASP.NET Core in three simple steps. 
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ASP.NET MVC Application Request life cycle]]></title>
            <link>https://www.dotnetweekly.com/articles/aspnet-mvc-application-request-life-cycle</link>
            <guid>https://www.dotnetweekly.com/articles/aspnet-mvc-application-request-life-cycle</guid>
            <pubDate>Mon, 30 Nov 2020 02:35:22 GMT</pubDate>
            <content:encoded><![CDATA[This article describes the ASP.NET MVC request life cycle, it explains how request flows from the user browser to MVC application and vice versa.

This gives you detail description of ASP.NET MVC request steps like routing, MvcHandler, Controller, Action Execution, View Result, View Engine, and View.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Fluent Generics in C#]]></title>
            <link>https://www.dotnetweekly.com/articles/fluent-generics-in-c</link>
            <guid>https://www.dotnetweekly.com/articles/fluent-generics-in-c</guid>
            <pubDate>Mon, 30 Nov 2020 02:20:19 GMT</pubDate>
            <content:encoded><![CDATA[Generics is a powerful feature available in many statically typed languages. It offers a way to write code that seamlessly operates against many different types, by targeting the features they share rather than the types themselves. This provides the means for building flexible and reusable components without having to sacrifice type safety or introduce unnecessary duplication.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Common async pitfalls—part one]]></title>
            <link>https://www.dotnetweekly.com/articles/common-async-pitfallspart-one</link>
            <guid>https://www.dotnetweekly.com/articles/common-async-pitfallspart-one</guid>
            <pubDate>Mon, 30 Nov 2020 02:19:52 GMT</pubDate>
            <content:encoded><![CDATA[The .NET Framework provides a great programming model that enables high performance code using an easy to understand syntax. However, this can often give developers a false sense of security, and the language and runtime aren’t without pitfalls. Ideally static analysers, like the Microsoft.VisualStudio.Threading.Analyzers Roslyn analysers, would catch all these issues at build time. While they do help catch a lot of mistakes, they can’t catch everything, so it’s important to understand the problems and how to avoid them.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Astonishing Performance of .NET 5: More Data]]></title>
            <link>https://www.dotnetweekly.com/articles/astonishing-performance-of-net-5-more-data</link>
            <guid>https://www.dotnetweekly.com/articles/astonishing-performance-of-net-5-more-data</guid>
            <pubDate>Mon, 30 Nov 2020 02:19:31 GMT</pubDate>
            <content:encoded><![CDATA[The same day .NET 5 was released I shared a single screenshot showing how much faster .NET 5 is relatively to .NET Core 3.1. I promised to share more data later — and here it is.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[No-nonsense gRPC guide for the C# developers, Part One: Basic Service]]></title>
            <link>https://www.dotnetweekly.com/articles/no-nonsense-grpc-guide-for-the-c-developers-part-one-basic-service</link>
            <guid>https://www.dotnetweekly.com/articles/no-nonsense-grpc-guide-for-the-c-developers-part-one-basic-service</guid>
            <pubDate>Mon, 30 Nov 2020 02:19:17 GMT</pubDate>
            <content:encoded><![CDATA[gRPC is a high performance program-to-program communication framework highly suitable to efficiently connect services and, as such, to serve as the foundation for the micro-service architecture. I will not to bore you with the marketing speech, go for the details to the official site

]]></content:encoded>
        </item>
    </channel>
</rss>