<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Fri, 23 Aug 2019 01:56:51 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <item>
            <title><![CDATA[JazSharp]]></title>
            <link>https://www.dotnetweekly.com/articles/jazsharp</link>
            <guid>https://www.dotnetweekly.com/articles/jazsharp</guid>
            <pubDate>Thu, 22 Aug 2019 01:32:25 GMT</pubDate>
            <content:encoded><![CDATA[JazSharp is heavily inspired by Jasmine - the JavaScript unit testing framework. Angular developers will be very familiar with it since that is the unit testing framework used in a CLI created default app.

Why was this made?
Originally, JazSharp was only aiming to be a mocking framework but after the initial implementation attempts proved to be unreliable, the scope increased to be a full unit testing framework.

The benefits of JazSharp over other mocking frameworks are:

No reliance on interfaces or similar layers of separation that are not motivated by clean development practises.
No issues when testing code that changes static/global values for the app - statics methods and properties can be mocked just like any method.
An alternative approach to defining mocks. This is less of a benefit and more of a personal preference. For example, parameters can be checked after a mock is called and defining a mock is quick and easy.
The syntax used to define test methods is also very different from other .Net testing frameworks and allows test names (or descriptions in the case of JazSharp) to read more clearly both to technical and non-technical persons.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[One simple action you can take to prevent 99.9 percent of attacks on your accounts]]></title>
            <link>https://www.dotnetweekly.com/articles/one-simple-action-you-can-take-to-prevent-999-percent-of-attacks-on-your-accounts</link>
            <guid>https://www.dotnetweekly.com/articles/one-simple-action-you-can-take-to-prevent-999-percent-of-attacks-on-your-accounts</guid>
            <pubDate>Thu, 22 Aug 2019 01:30:46 GMT</pubDate>
            <content:encoded><![CDATA[There are over 300 million fraudulent sign-in attempts to our cloud services every day. Cyberattacks aren’t slowing down, and it’s worth noting that many attacks have been successful without the use of advanced technology. All it takes is one compromised credential or one legacy application to cause a data breach. This underscores how critical it is to ensure password security and strong authentication. Read on to learn about common vulnerabilities and the single action you can take to protect your accounts from attacks.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Understanding Azure Durable Functions - Part 7: The Function Chaining Pattern]]></title>
            <link>https://www.dotnetweekly.com/articles/understanding-azure-durable-functions-part-7-the-function-chaining-pattern</link>
            <guid>https://www.dotnetweekly.com/articles/understanding-azure-durable-functions-part-7-the-function-chaining-pattern</guid>
            <pubDate>Thu, 22 Aug 2019 01:29:59 GMT</pubDate>
            <content:encoded><![CDATA[This is the seventh part in a series of articles. If you’re not familiar with Durable Functions you should check out the previous articles before reading this.

There are a number of patterns that Durable Functions make easier to implement, we’ll look at some more later in this series of articles.

One common scenario is the requirement to create a “pipeline” of processing where the output from one Azure Function feeds into the next function in the chain/pipeline. This pattern can be implemented without Durable Functions, for example by manually setting up different queues to pass work down the chain. One downside to this manual approach is that it’s not sometimes immediately obvious what functions are involved in the the pipeline. Function chaining with Durable Functions allows the chain/pipeline to be easy to understand because the entire pipeline is represented in code.

To implement the function chaining pattern, you simply call one activity function and pass in  the input from a previous activity function.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to automate REST API end-to-end tests in a CI environment with Postman and Newman]]></title>
            <link>https://www.dotnetweekly.com/articles/how-to-automate-rest-api-end-to-end-tests-in-a-ci-environment-with-postman-and-newman</link>
            <guid>https://www.dotnetweekly.com/articles/how-to-automate-rest-api-end-to-end-tests-in-a-ci-environment-with-postman-and-newman</guid>
            <pubDate>Thu, 22 Aug 2019 01:29:32 GMT</pubDate>
            <content:encoded><![CDATA[Postman is a great tool to explore REST APIs. You can build requests and try them out to get quick feedback. Then you can persist them as collections to make sure that the knowledge doesn't get lost.

Newman, the CLI version of Postman, allows you to take it to the next level and transform a collection into a suite of automated end-to-end tests. This suite will run then in your CI tool of choice. In this article, I will explore the benefits of doing so and show you how to set it up.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Announcing the preview of GitHub Actions for Azure]]></title>
            <link>https://www.dotnetweekly.com/articles/announcing-the-preview-of-github-actions-for-azure</link>
            <guid>https://www.dotnetweekly.com/articles/announcing-the-preview-of-github-actions-for-azure</guid>
            <pubDate>Thu, 22 Aug 2019 01:17:27 GMT</pubDate>
            <content:encoded><![CDATA[On Thursday, August 8, 2019, GitHub announced the preview of GitHub Actions with support for Continuous Integration and Continuous Delivery (CI/CD). Actions makes it possible to create simple, yet powerful pipelines and automate software compilation and delivery. Today, we are announcing the preview of GitHub Actions for Azure.

With these new Actions, developers can quickly build, test, and deploy code from GitHub repositories to the cloud with Azure.

You can find our first set of Actions grouped into four repositories on GitHub, each one containing documentation and examples to help you use GitHub for CI/CD and deploy your apps to Azure.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azure Tips and Tricks]]></title>
            <link>https://www.dotnetweekly.com/articles/azure-tips-and-tricks</link>
            <guid>https://www.dotnetweekly.com/articles/azure-tips-and-tricks</guid>
            <pubDate>Thu, 22 Aug 2019 01:15:21 GMT</pubDate>
            <content:encoded><![CDATA[Welcome to Azure Tips and Tricks, this site is a special collection of over 210+ tips, videos, conference talks, and eBooks that span the entire universe of the Azure platform. The tips you'll find here are based on real-world scenarios that I've encountered (along with the community) while using Azure. Feel free to jump in and come back weekly for new tips!]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing Microsoft Edge Beta: Be one of the first to try it now]]></title>
            <link>https://www.dotnetweekly.com/articles/introducing-microsoft-edge-beta-be-one-of-the-first-to-try-it-now</link>
            <guid>https://www.dotnetweekly.com/articles/introducing-microsoft-edge-beta-be-one-of-the-first-to-try-it-now</guid>
            <pubDate>Thu, 22 Aug 2019 01:14:19 GMT</pubDate>
            <content:encoded><![CDATA[Today I’m thrilled to announce that a Beta release for the next version of Microsoft Edge is now available for all supported versions of Windows and macOS. Our goal with Microsoft Edge is to create better web compatibility with better performance for our customers while ensuring less fragmentation of the web for all web developers. Our community has been with us on this journey from the beginning and your feedback is making it possible to rapidly improve. To date, there have been more than one million downloads of our preview builds, across all supported versions of Windows and Mac, from which we have received more than 140,000 individual pieces of feedback. Thank you!  

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[6 Steps to Consume ASP.NET Core Web API in Xamarin Applications]]></title>
            <link>https://www.dotnetweekly.com/articles/6-steps-to-consume-aspnet-core-web-api-in-xamarin-applications</link>
            <guid>https://www.dotnetweekly.com/articles/6-steps-to-consume-aspnet-core-web-api-in-xamarin-applications</guid>
            <pubDate>Wed, 21 Aug 2019 11:45:50 GMT</pubDate>
            <content:encoded><![CDATA[Form this blog post, learn how to consume the ASP.NET Core Web (or REST) APIs in Xamarin.Forms application.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Trying to Run RSocket Server with RSocket.NET and ASP.NET Core Primitives for Non-HTTP Servers]]></title>
            <link>https://www.dotnetweekly.com/articles/trying-to-run-rsocket-server-with-rsocketnet-and-aspnet-core-primitives-for-non-http-servers</link>
            <guid>https://www.dotnetweekly.com/articles/trying-to-run-rsocket-server-with-rsocketnet-and-aspnet-core-primitives-for-non-http-servers</guid>
            <pubDate>Wed, 21 Aug 2019 07:35:29 GMT</pubDate>
            <content:encoded><![CDATA[This post describes an attempt to build a proof-of-concept RSocket server by putting together RSoket.NET and new ASP.NET Core networking primitives for non-HTTP servers.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaScript & Node.js testing best practices]]></title>
            <link>https://www.dotnetweekly.com/articles/javascript-and-nodejs-testing-best-practices</link>
            <guid>https://www.dotnetweekly.com/articles/javascript-and-nodejs-testing-best-practices</guid>
            <pubDate>Mon, 19 Aug 2019 23:30:46 GMT</pubDate>
            <content:encoded><![CDATA[Table of contents
Section 0: The Golden Rule
Single advice that inspires all the others (1 special bullet)

Section 1: The Test Anatomy
The foundation - structuring clean tests (12 bullets)

Section 2: Backend
Writing backend and Microservices tests efficiently (8 bullets)

Section 3: Frontend, UI, E2E
Writing tests for web UI including component and E2E tests (11 bullets)

Section 4: Measuring Tests Effectiveness
Watching the watchman - measuring test quality (4 bullets)

Section 5: Continous Integration
Guidelines for CI in the JS world (9 bullets)

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Getting Started with gRPC Client Factory]]></title>
            <link>https://www.dotnetweekly.com/articles/getting-started-with-grpc-client-factory</link>
            <guid>https://www.dotnetweekly.com/articles/getting-started-with-grpc-client-factory</guid>
            <pubDate>Mon, 19 Aug 2019 23:29:44 GMT</pubDate>
            <content:encoded><![CDATA[Regular visitors of my blog will know that I’ve written a lot of posts about the HttpClientFactory feature, available in the Microsoft.Extensions.Http package which simplifies the consumption and proper lifetime usage of HttpClient instances.

Recently, I’ve begun digging into gRPC and I’m pleased to see a similar pattern is available for gRPC-based communication.

In this post, I want to show a quick example of how to get started with the gRPC Client Factory. I’m going to focus on adding this to an ASP.NET Core 3.0 web project, which will act as a client of an external gRPC service. This post assumes a little knowledge about gRPC. You can read my earlier blog post (slightly outdated now) which covers some extra ground.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[DevOps for .Net Core/.Net Standard: Common CI Issues Solving]]></title>
            <link>https://www.dotnetweekly.com/articles/devops-for-net-core-net-standard-common-ci-issues-solving</link>
            <guid>https://www.dotnetweekly.com/articles/devops-for-net-core-net-standard-common-ci-issues-solving</guid>
            <pubDate>Mon, 19 Aug 2019 23:29:07 GMT</pubDate>
            <content:encoded><![CDATA[Recently got chances to work on Azure DevOps for Desktop (UWP/WPF/Desktop Bridge/MSIX) , and often need to CI/CD .Net Core and .Net Standard. Most of them are related to SDK setup, NuGet version update, TargetPlatform settings, or Code Sign Certificate trust. This article is to give quick references on how to solve common CI issues for this scenario.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A plugin system with .NET Core]]></title>
            <link>https://www.dotnetweekly.com/articles/a-plugin-system-with-net-core</link>
            <guid>https://www.dotnetweekly.com/articles/a-plugin-system-with-net-core</guid>
            <pubDate>Mon, 19 Aug 2019 23:26:54 GMT</pubDate>
            <content:encoded><![CDATA[In this post, I show how you could implement a plugin system that can unload the plugins dynamically. I also provide some background information behind the techniques and classes involved. Unlike the AppDomain, the AssemblyLoadContext lets you unload the plugin types and the owned assemblies - sounds promising, right?]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Fantastic Front-End Performance Tricks & Why We Do Them]]></title>
            <link>https://www.dotnetweekly.com/articles/fantastic-front-end-performance-tricks-and-why-we-do-them</link>
            <guid>https://www.dotnetweekly.com/articles/fantastic-front-end-performance-tricks-and-why-we-do-them</guid>
            <pubDate>Mon, 19 Aug 2019 23:26:08 GMT</pubDate>
            <content:encoded><![CDATA[In Part 1, we explored why front-end performance is an essential ingredient for any website serious about achieving its goals. We then learned about the common metrics which are used to measure major performance as well as some for the best tools to collect this data for you.

Now that we know how to measure and understand a website’s current performance, in Part 2, we’re going to talk about some of the recommended front-end performance optimization techniques you can use to improve it. All of these can be built into your web development workflow starting today.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Logging in C# .NET Modern-day Practices: The Complete Guide]]></title>
            <link>https://www.dotnetweekly.com/articles/logging-in-c-net-modern-day-practices-the-complete-guide</link>
            <guid>https://www.dotnetweekly.com/articles/logging-in-c-net-modern-day-practices-the-complete-guide</guid>
            <pubDate>Mon, 19 Aug 2019 23:23:52 GMT</pubDate>
            <content:encoded><![CDATA[Logging is a big part of software development for many years now. One can argue that a logging mechanism is a must-have part of any application or library. I would agree with that statement.

Logging has a crucial part to play in a scenario where you can’t use interactive debugging (that is, attaching a debugger like Visual Studio). It allows us to investigate errors after the problem already happened. In some cases, like Production Debugging, logs might be the only information you have.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Avoid multithreading traps with Roslyn: Lock object selection ]]></title>
            <link>https://www.dotnetweekly.com/articles/avoid-multithreading-traps-with-roslyn-lock-object-selection</link>
            <guid>https://www.dotnetweekly.com/articles/avoid-multithreading-traps-with-roslyn-lock-object-selection</guid>
            <pubDate>Mon, 19 Aug 2019 15:18:39 GMT</pubDate>
            <content:encoded><![CDATA[ I’ve decided to create a series of blog posts where I will present what I’ve recently learned about the traps related to the multithreading in C#. I will also show you my proposition of Roslyn analyzers that can possibly help to avoid those issues right at the stage of writing the code. This part is about choosing a suitable object for locking.]]></content:encoded>
        </item>
    </channel>
</rss>