<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Tue, 24 Mar 2020 17:29:01 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <item>
            <title><![CDATA[Continuous integration and deployment for desktop apps with GitHub Actions]]></title>
            <link>https://www.dotnetweekly.com/articles/continuous-integration-and-deployment-for-desktop-apps-with-github-actions</link>
            <guid>https://www.dotnetweekly.com/articles/continuous-integration-and-deployment-for-desktop-apps-with-github-actions</guid>
            <pubDate>Tue, 24 Mar 2020 17:17:49 GMT</pubDate>
            <content:encoded><![CDATA[From speaking to desktop developers, we’ve heard that you want to learn how to quickly set up continuous integration and continuous deployment (CI/CD) workflows for your WPF and Windows Forms applications in order to take advantage of the many benefits CI/CD pipelines have to offer, such as:

Catch bugs early in the development cycle
Improve software quality and reliability
Ensure consistent quality of builds
Deploy new features quickly and safely, improving release cadence
Fix issues quickly in production by rolling forward new deployments]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Visual Studio Code Docker extension 1.0 – Better than Ever!]]></title>
            <link>https://www.dotnetweekly.com/articles/visual-studio-code-docker-extension-10-better-than-ever</link>
            <guid>https://www.dotnetweekly.com/articles/visual-studio-code-docker-extension-10-better-than-ever</guid>
            <pubDate>Tue, 24 Mar 2020 17:17:18 GMT</pubDate>
            <content:encoded><![CDATA[We recently released the 1.0 version of our Visual Studio Code Docker extension, which is the first general availability (GA) release. The Docker extension makes it easier to build apps that leverage Docker containers. The extension helps scaffold needed files, build Docker images, debug your app inside a container, and an explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Every Web Performance Test Tool]]></title>
            <link>https://www.dotnetweekly.com/articles/every-web-performance-test-tool</link>
            <guid>https://www.dotnetweekly.com/articles/every-web-performance-test-tool</guid>
            <pubDate>Tue, 24 Mar 2020 17:15:57 GMT</pubDate>
            <content:encoded><![CDATA[Here is every Web Performance Test Tool I know of to help identify issues in your site/get you some key speed metrics. The idea is you think of a feature you want, e.g. "TTFB" or "locations" or "waterfall" and just Cmd + F on this page to find a tool that helps you with that thing.

Please let me know if you have other tools that belong here]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CQRS]]></title>
            <link>https://www.dotnetweekly.com/articles/cqrs</link>
            <guid>https://www.dotnetweekly.com/articles/cqrs</guid>
            <pubDate>Tue, 24 Mar 2020 17:11:57 GMT</pubDate>
            <content:encoded><![CDATA[CQRS is a simple pattern that strictly segregates the responsibility of handling command input into an autonomous system from the responsibility of handling side-effect-free query/read access on the same system.

If you are familiar with Domain-Driven Design, you’ve most likely heard about, Command-Query Responsibility Segregation (CQRS). Though the CQRS pattern is well-known, there are still a lot of misconceptions around this pattern, especially when it comes to applying it in real-world software projects.

In this article, you will learn exactly what CQRS is, the principles behind it, and the benefits it can provide for your project.

We will see a detailed, step-by-step process of implementing this pattern in practice using a sample project we’ll be working on. This project will be close to what you can see in the real world, and I will explain each step on the way to implement CQRS in great detail.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to create better code using Domain-Driven Design]]></title>
            <link>https://www.dotnetweekly.com/articles/how-to-create-better-code-using-domain-driven-design</link>
            <guid>https://www.dotnetweekly.com/articles/how-to-create-better-code-using-domain-driven-design</guid>
            <pubDate>Tue, 24 Mar 2020 17:06:54 GMT</pubDate>
            <content:encoded><![CDATA[In this post, I am going to present how you can use domain-driven design tactical patterns like value object, entity, repository, domain event, factory, and domain service, to write better code. By better code I mean code that is more readable, easier to reason about and maintain. We will start with business requirements, then we will have a look at implementation that does not use domain driven design and has an anemic model, then we will analyze problems related to such approach and compare it with code build with help of domain-driven design tactical patterns.
The source code for this post is located here at Altkom Software & Consulting Github.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[npm is joining GitHub]]></title>
            <link>https://www.dotnetweekly.com/articles/npm-is-joining-github</link>
            <guid>https://www.dotnetweekly.com/articles/npm-is-joining-github</guid>
            <pubDate>Tue, 24 Mar 2020 16:52:47 GMT</pubDate>
            <content:encoded><![CDATA[I’m excited to announce that GitHub has signed an agreement to acquire npm.

npm is a critical part of the JavaScript world. The work of the npm team over the last 10 years, and the contributions of hundreds of thousands of open source developers and maintainers, have made npm home to over 1.3 million packages with 75 billion downloads a month. Together, they’ve helped JavaScript become the largest developer ecosystem in the world. We at GitHub are honored to be part of the next chapter of npm’s story and to help npm continue to scale to meet the needs of the fast-growing JavaScript community. ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Flexible CI/CD with Kubernetes, Helm, Traefik and Jenkins]]></title>
            <link>https://www.dotnetweekly.com/articles/flexible-ci-cd-with-kubernetes-helm-traefik-and-jenkins</link>
            <guid>https://www.dotnetweekly.com/articles/flexible-ci-cd-with-kubernetes-helm-traefik-and-jenkins</guid>
            <pubDate>Tue, 24 Mar 2020 16:50:45 GMT</pubDate>
            <content:encoded><![CDATA[The main goal is to present a flexible CI/CD solution on top of Kubernetes, with automatic application deployment, host definition and routing per environment. To make this process easy to understand, the following steps are presented and described in detail:

Setup Kubernetes and understand its basic concepts;
Install Traefik, Dashboard and Jenkins using Helm;
Create Kotlin application to show how CI/CD can be used;
Implement Jenkins pipeline to build and deploy application automatically.
To fulfill the mentioned steps and validate the presented CI/CD solution, the architecture with the following components is proposed:

Kubernetes: for containers management and orchestration;
Traefik: as proxy and load balancer to access services;
Kubernetes Dashboard: to manage Kubernetes through a web-based interface;
Jenkins: as automation server to automatically build and deploy application;
GitHub: to manage source code using Git;
DockerHub: as registry to manage the Docker image with the example application;
Application stating: example application deployment for development and testing purposes;
Application production: example application deployment to be used in production.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Intro to quantum computing with Q# – Part 1, The background and the qubit]]></title>
            <link>https://www.dotnetweekly.com/articles/intro-to-quantum-computing-with-q-part-1-the-background-and-the-qubit</link>
            <guid>https://www.dotnetweekly.com/articles/intro-to-quantum-computing-with-q-part-1-the-background-and-the-qubit</guid>
            <pubDate>Tue, 24 Mar 2020 16:45:10 GMT</pubDate>
            <content:encoded><![CDATA[Quantum mechanics is one of the fundamental theories of physics, and has been tremendously successful at describing the behavior of subatomic particles. However, its counter-intuitive probabilistic nature, bizarre rules and confusing epistemology have troubled some of the greatest physicists of the 20th century, even prompting Albert Einstein to remark “Old Man (often translated as 'God') doesn't play dice”.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Learning and documenting .NET with dotnet try]]></title>
            <link>https://www.dotnetweekly.com/articles/learning-and-documenting-net-with-dotnet-try</link>
            <guid>https://www.dotnetweekly.com/articles/learning-and-documenting-net-with-dotnet-try</guid>
            <pubDate>Tue, 24 Mar 2020 16:18:16 GMT</pubDate>
            <content:encoded><![CDATA[Learning a new programming language is always hard. You have to read the documentation, stop, go to the IDE of your choice, start a new project, compile and run the program and see the results. Stop. Restart. After some time, you have no more patience for the process and start to skip some steps (maybe I don’t need to run this sample here…) until the point that you try to find an easier way, but most of the time there is no easier way.

Well, now there is an easier way. The dotnet team has created a new tool, called dotnet try that allows you to have documentation mixed with a code sample window, where you can try the code while reading the documentation. Cool, no?]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Using GitHub Actions to deploy a .Net Web App]]></title>
            <link>https://www.dotnetweekly.com/articles/using-github-actions-to-deploy-a-net-web-app</link>
            <guid>https://www.dotnetweekly.com/articles/using-github-actions-to-deploy-a-net-web-app</guid>
            <pubDate>Tue, 24 Mar 2020 16:13:26 GMT</pubDate>
            <content:encoded><![CDATA[So I wanted to take a look into GitHub Action’s and deploy a .Net Web App, this is my first real look into them and will be blogging about them a lot more in the future, below are the steps I took to do this.

Create a basic .Net MVC Web App using .Net Core 3.1
Run the app and make sure all is working as expected.
Deploy this to Azure web app to Azure and check it runs ok.
I then go into my Resource Group, locate the app service and from the click on ‘Get publish profile‘ – download the file and keep handy.
Then I added the code to GitHub in a new repo which you can find here: – https://github.com/gsuttie/GHActionsWebApp1
Next, I need to create a secret from within GitHub, so once you have your code in a new repository within Github go click on Settings and then Security and click Add a new secret, call it azureWebAppPublishProfile if you want to use the YAML below.
Then I click on Actions and create my first workflow, I chose, Setup a workflow yourself.
And then from here – https://github.com/actions/setup-dotnet I used the YAML and pasted in so that my main.yaml file looks like this]]></content:encoded>
        </item>
    </channel>
</rss>