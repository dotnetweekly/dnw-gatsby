<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Wed, 18 Sep 2019 01:47:35 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Libraries-Tools</category>
        <category>Articles</category>
        <item>
            <title><![CDATA[https://www.hanselman.com/blog/VisualStudioNowIncludesAnIntegratedTerminal.aspx]]></title>
            <link>https://www.dotnetweekly.com/articles/https-wwwhanselmancom-blog-visualstudionowincludesanintegratedterminalaspx</link>
            <guid>https://www.dotnetweekly.com/articles/https-wwwhanselmancom-blog-visualstudionowincludesanintegratedterminalaspx</guid>
            <pubDate>Mon, 16 Sep 2019 01:27:12 GMT</pubDate>
            <content:encoded><![CDATA[It's early days (preview) but there's now a Terminal integrated into Visual Studio! Taking a nod from the 2017 plugin, the Terminal is now build in as an experimental feature using features from the NEW open source Windows Terminal.

Rather than build everything from scratch, the Visual Studio terminal shares most of its core with the Windows Terminal!

assuming you have Visual Studio 2019 16.3 Preview 3 or above, you’ll want to enable it by visiting the Preview Features page. Go to Tools > Options > Preview Features, enable the Experimental VS Terminal option and restart Visual Studio.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Combining Razor and Blazor Pages in a Single ASP.NET Core 3 Application]]></title>
            <link>https://www.dotnetweekly.com/articles/combining-razor-and-blazor-pages-in-a-single-aspnet-core-3-application</link>
            <guid>https://www.dotnetweekly.com/articles/combining-razor-and-blazor-pages-in-a-single-aspnet-core-3-application</guid>
            <pubDate>Mon, 16 Sep 2019 01:26:08 GMT</pubDate>
            <content:encoded><![CDATA[First RTM release of Blazor should happen in two weeks. Things are still changing quite rapidly, and the latest preview 9 made the interop between Razor Pages and Blazor components much harder: It’s not possible anymore to pass parameters from a Razor Page to a Blazor component using Html.RenderComponentAsync. This may change in future but it’s quite likely that .NET Core 3.0 will arrive with this limitation.

If you still would like to enhance your existing Razor Pages based application with some Blazor magic, one solution is completely create your pages in Blazor. This post shows you can add Blazor based pages into an existing Razor Pages application, where parts of the app are created using Razor Pages and parts of the app are created using Blazor Pages. Same layout is used for both types of pages.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Healthcheck endpoints in C# in MVC projects using ASP.NET Core, and writing results to Azure Application Insights]]></title>
            <link>https://www.dotnetweekly.com/articles/healthcheck-endpoints-in-c-in-mvc-projects-using-aspnet-core-and-writing-results-to-azure-applicati</link>
            <guid>https://www.dotnetweekly.com/articles/healthcheck-endpoints-in-c-in-mvc-projects-using-aspnet-core-and-writing-results-to-azure-applicati</guid>
            <pubDate>Mon, 16 Sep 2019 01:25:21 GMT</pubDate>
            <content:encoded><![CDATA[Every developer wants to build a system that never breaks, but in reality things go wrong. The best systems are built to expect that and handle problems, that rather than just silently failing.

Maybe your database becomes unavailable (e.g. runs out of hard disk space) and your failover doesn’t work – or maybe a third party web service that you depend on stops working.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Learning the hard way: Microservices]]></title>
            <link>https://www.dotnetweekly.com/articles/learning-the-hard-way-microservices</link>
            <guid>https://www.dotnetweekly.com/articles/learning-the-hard-way-microservices</guid>
            <pubDate>Mon, 16 Sep 2019 01:14:37 GMT</pubDate>
            <content:encoded><![CDATA[In late 2016, my team and I started building a brand new platform. Having a blank slate like this is a developer’s dream — no legacy code, no backward compatibility to worry about, and best of all, we could choose The Right Technology™ for the job.
Three years later, after much pain and suffering, I’m here to do a bit of a retrospective. Before diving in though, I’m going to acknowledge two things.

Hindsight is 20/20
There is no silver bullet

There’s no way of knowing if doing things differently would have resulted in less frustration, but there were definitely some key pieces of very important advice around domain/architecture which we chose to ignore. At the time, we thought we knew better.
So for those who are embarking on similar journeys, here are some of the biggest pieces of advice I regret not taking.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Task Parallelism C#]]></title>
            <link>https://www.dotnetweekly.com/articles/task-parallelism-c</link>
            <guid>https://www.dotnetweekly.com/articles/task-parallelism-c</guid>
            <pubDate>Mon, 16 Sep 2019 01:13:54 GMT</pubDate>
            <content:encoded><![CDATA[Task parallelism is the process of running tasks in parallel. Task parallelism divides tasks and allocates those tasks to separate threads for processing. It is based on unstructured parallelism. It means the parallel work unit may start and finish in places scattered according to the the executing of the program.

In this article, we will be discussing different methods to achieve parallelism using Tasks in C#.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[File uploads with Blazor]]></title>
            <link>https://www.dotnetweekly.com/articles/file-uploads-with-blazor</link>
            <guid>https://www.dotnetweekly.com/articles/file-uploads-with-blazor</guid>
            <pubDate>Mon, 16 Sep 2019 01:13:33 GMT</pubDate>
            <content:encoded><![CDATA[For a long time we’ve expected that we’d add a built-in “file input” feature to Blazor. This would let users pick local files and supply them to your application. Possible uses cases include:

You want to upload and store those files on a server
Or, you want to read and import some data from them
Or, you want to present an editor UI for the file
It applies equally to client-side or server-side Blazor. In client-side Blazor, you’re loading the file into the .NET application’s memory, which can then edit it locally or could make an HTTP request to transfer it to some backend server. In server-side Blazor, your code is already running on the server, but you still want to be able to read files picked by the user.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Frustrations with React Hooks]]></title>
            <link>https://www.dotnetweekly.com/articles/frustrations-with-react-hooks</link>
            <guid>https://www.dotnetweekly.com/articles/frustrations-with-react-hooks</guid>
            <pubDate>Mon, 16 Sep 2019 01:13:09 GMT</pubDate>
            <content:encoded><![CDATA[Before I detail my current frustrations with Hooks I do want to state for the record that I am, for the most part, a fan of Hooks.

I often hear that the main reason for the existence of Hooks is to replace class components. Sadly, the main heading in the official React site’s post introducing Hooks really undersells Hooks with this not-so-bold statement:

Hooks are a new addition in React 16.8. They let you use state, and other React features without writing a class.]]></content:encoded>
        </item>
    </channel>
</rss>