<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Sun, 18 Aug 2019 23:32:51 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <item>
            <title><![CDATA[JavaScript & Node.js testing best practices]]></title>
            <link>https://www.dotnetweekly.com/articles/javascript-and-nodejs-testing-best-practices</link>
            <guid>https://www.dotnetweekly.com/articles/javascript-and-nodejs-testing-best-practices</guid>
            <pubDate>Mon, 19 Aug 2019 23:30:46 GMT</pubDate>
            <content:encoded><![CDATA[Table of contents
Section 0: The Golden Rule
Single advice that inspires all the others (1 special bullet)

Section 1: The Test Anatomy
The foundation - structuring clean tests (12 bullets)

Section 2: Backend
Writing backend and Microservices tests efficiently (8 bullets)

Section 3: Frontend, UI, E2E
Writing tests for web UI including component and E2E tests (11 bullets)

Section 4: Measuring Tests Effectiveness
Watching the watchman - measuring test quality (4 bullets)

Section 5: Continous Integration
Guidelines for CI in the JS world (9 bullets)

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Getting Started with gRPC Client Factory]]></title>
            <link>https://www.dotnetweekly.com/articles/getting-started-with-grpc-client-factory</link>
            <guid>https://www.dotnetweekly.com/articles/getting-started-with-grpc-client-factory</guid>
            <pubDate>Mon, 19 Aug 2019 23:29:44 GMT</pubDate>
            <content:encoded><![CDATA[Regular visitors of my blog will know that I’ve written a lot of posts about the HttpClientFactory feature, available in the Microsoft.Extensions.Http package which simplifies the consumption and proper lifetime usage of HttpClient instances.

Recently, I’ve begun digging into gRPC and I’m pleased to see a similar pattern is available for gRPC-based communication.

In this post, I want to show a quick example of how to get started with the gRPC Client Factory. I’m going to focus on adding this to an ASP.NET Core 3.0 web project, which will act as a client of an external gRPC service. This post assumes a little knowledge about gRPC. You can read my earlier blog post (slightly outdated now) which covers some extra ground.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[DevOps for .Net Core/.Net Standard: Common CI Issues Solving]]></title>
            <link>https://www.dotnetweekly.com/articles/devops-for-net-core-net-standard-common-ci-issues-solving</link>
            <guid>https://www.dotnetweekly.com/articles/devops-for-net-core-net-standard-common-ci-issues-solving</guid>
            <pubDate>Mon, 19 Aug 2019 23:29:07 GMT</pubDate>
            <content:encoded><![CDATA[Recently got chances to work on Azure DevOps for Desktop (UWP/WPF/Desktop Bridge/MSIX) , and often need to CI/CD .Net Core and .Net Standard. Most of them are related to SDK setup, NuGet version update, TargetPlatform settings, or Code Sign Certificate trust. This article is to give quick references on how to solve common CI issues for this scenario.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A plugin system with .NET Core]]></title>
            <link>https://www.dotnetweekly.com/articles/a-plugin-system-with-net-core</link>
            <guid>https://www.dotnetweekly.com/articles/a-plugin-system-with-net-core</guid>
            <pubDate>Mon, 19 Aug 2019 23:26:54 GMT</pubDate>
            <content:encoded><![CDATA[In this post, I show how you could implement a plugin system that can unload the plugins dynamically. I also provide some background information behind the techniques and classes involved. Unlike the AppDomain, the AssemblyLoadContext lets you unload the plugin types and the owned assemblies - sounds promising, right?]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Fantastic Front-End Performance Tricks & Why We Do Them]]></title>
            <link>https://www.dotnetweekly.com/articles/fantastic-front-end-performance-tricks-and-why-we-do-them</link>
            <guid>https://www.dotnetweekly.com/articles/fantastic-front-end-performance-tricks-and-why-we-do-them</guid>
            <pubDate>Mon, 19 Aug 2019 23:26:08 GMT</pubDate>
            <content:encoded><![CDATA[In Part 1, we explored why front-end performance is an essential ingredient for any website serious about achieving its goals. We then learned about the common metrics which are used to measure major performance as well as some for the best tools to collect this data for you.

Now that we know how to measure and understand a website’s current performance, in Part 2, we’re going to talk about some of the recommended front-end performance optimization techniques you can use to improve it. All of these can be built into your web development workflow starting today.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Logging in C# .NET Modern-day Practices: The Complete Guide]]></title>
            <link>https://www.dotnetweekly.com/articles/logging-in-c-net-modern-day-practices-the-complete-guide</link>
            <guid>https://www.dotnetweekly.com/articles/logging-in-c-net-modern-day-practices-the-complete-guide</guid>
            <pubDate>Mon, 19 Aug 2019 23:23:52 GMT</pubDate>
            <content:encoded><![CDATA[Logging is a big part of software development for many years now. One can argue that a logging mechanism is a must-have part of any application or library. I would agree with that statement.

Logging has a crucial part to play in a scenario where you can’t use interactive debugging (that is, attaching a debugger like Visual Studio). It allows us to investigate errors after the problem already happened. In some cases, like Production Debugging, logs might be the only information you have.]]></content:encoded>
        </item>
    </channel>
</rss>