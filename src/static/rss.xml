<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Thu, 29 Aug 2019 04:00:17 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Events-training</category>
        <category>Articles</category>
        <category>Libraries-Tools</category>
        <item>
            <title><![CDATA[.NET Conf 2019 Teaser]]></title>
            <link>https://www.dotnetweekly.com/articles/net-conf-2019-teaser</link>
            <guid>https://www.dotnetweekly.com/articles/net-conf-2019-teaser</guid>
            <pubDate>Thu, 29 Aug 2019 03:48:38 GMT</pubDate>
            <content:encoded><![CDATA[.NET Conf is a FREE, 3 day virtual developer event co-organized by the .NET community and Microsoft. This year .NET Core 3.0 will launch at .NET Conf 2019! Come celebrate and learn about the new release!

Learn more at => https://www.dotnetconf.net/]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to get data for Data-Driven Tests?]]></title>
            <link>https://www.dotnetweekly.com/articles/how-to-get-data-for-data-driven-tests</link>
            <guid>https://www.dotnetweekly.com/articles/how-to-get-data-for-data-driven-tests</guid>
            <pubDate>Thu, 29 Aug 2019 03:46:55 GMT</pubDate>
            <content:encoded><![CDATA[This article is Part 2 in a 2-Part Series.

Part 1 - Refactoring to Data Driven Tests
Part 2 - This Article

The previous post was meant to be an encouragement and a warmup to data-driven testing. This post describes why I love this way of testing. Understanding a simple fact about testing moved me from “Oh, I should write tests” to “I want it all! And I want it now!” and Data-Driven Testing. And the simple truth is:]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Containerising a Blazor WebAssembly App]]></title>
            <link>https://www.dotnetweekly.com/articles/containerising-a-blazor-webassembly-app</link>
            <guid>https://www.dotnetweekly.com/articles/containerising-a-blazor-webassembly-app</guid>
            <pubDate>Thu, 29 Aug 2019 03:46:17 GMT</pubDate>
            <content:encoded><![CDATA[This is the second post in the series: Containerising Blazor Applications With Docker.

Part 1 - Containerising a Blazor Server App
Part 2 - Containerising a Blazor WebAssembly App (this post)

In part 1 of the series, we took a look Docker and some of its key concepts. Then we took the default template for a Blazor Server app and containerised it using Docker. In this post, we are going to take a look at doing the same thing but with a Blazor WebAssembly app.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ASP.NET Core Blazor — JavaScript Interop]]></title>
            <link>https://www.dotnetweekly.com/articles/aspnet-core-blazor-javascript-interop</link>
            <guid>https://www.dotnetweekly.com/articles/aspnet-core-blazor-javascript-interop</guid>
            <pubDate>Thu, 29 Aug 2019 03:45:36 GMT</pubDate>
            <content:encoded><![CDATA[Blazor is here, Will JavaScript be dead? I would say that the answer is NO at-least for now.
Even though Blazor is creating revolution in web technology, it need JavaScript to use web features that cannot be achieved by Blazor for now. To do this Blazor team has provided JavaScript Interop support that will enable us to do use JavaScript functions from C# and vice versa.
In this post we are going to see how to use JavaScript Interop in Blazor application and how to invoke JavaScript function from C# and vice versa.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Integration Testing with xUnit]]></title>
            <link>https://www.dotnetweekly.com/articles/integration-testing-with-xunit</link>
            <guid>https://www.dotnetweekly.com/articles/integration-testing-with-xunit</guid>
            <pubDate>Thu, 29 Aug 2019 03:44:07 GMT</pubDate>
            <content:encoded><![CDATA[A few years back, I had given up on xUnit in favor of Fixie because of the flexibility that Fixie provides. The xUnit project is highly opinionated and geared strictly towards unit tests. It's great for that.

A broader testing strategy includes much more than just unit tests. With Fixie, I can implement any of the XUnit Test Patterns to implement a comprehensive automated test strategy (rather than, say, having different test frameworks for different kinds of tests).

In unit tests, each test method is highly isolated. In integration tests, this is usually not the case. Integration tests usually "touch" a lot more than a single class, and almost always, interact with other processes, files, and I/O. Unit tests are in-process, integration tests are out-of-process.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Learning how to develop GraphQL solutions with .NET]]></title>
            <link>https://www.dotnetweekly.com/articles/learning-how-to-develop-graphql-solutions-with-net</link>
            <guid>https://www.dotnetweekly.com/articles/learning-how-to-develop-graphql-solutions-with-net</guid>
            <pubDate>Thu, 29 Aug 2019 03:42:17 GMT</pubDate>
            <content:encoded><![CDATA[If you are building a data-driven web or mobile application, then key concerns you need to address is how data will be surfaced to the client and how the client can update the state on the server. This is not a new problem, and one that we have been solving for decades.

GraphQL provides one way to address this problem and uses an approach that provides significant benefits over previous RPC-based approaches. GraphQL was originally created at Facebook several years ago. It has been widely adopted since by Github, Concur, Airbnb and more. We’re even now adopting it at DocuSign. If you are doing React development, GraphQL has become the de-facto way to query from React clients.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Playing with the Azure CLI - Productive C# Podcast]]></title>
            <link>https://www.dotnetweekly.com/articles/playing-with-the-azure-cli-productive-c-podcast</link>
            <guid>https://www.dotnetweekly.com/articles/playing-with-the-azure-cli-productive-c-podcast</guid>
            <pubDate>Wed, 28 Aug 2019 19:27:39 GMT</pubDate>
            <content:encoded><![CDATA[The Azure CLI is a command-line tool that provides a fantastic experience to work with Azure resources. In this episode, I share my first-time experience with it and how you can get started using it. It's definitely the best tool for the job!]]></content:encoded>
        </item>
    </channel>
</rss>