<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Thu, 22 Apr 2021 17:39:41 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Videos</category>
        <category>Articles</category>
        <category>Libraries-Tools</category>
        <item>
            <title><![CDATA[Build Automation with NUKE]]></title>
            <link>https://www.dotnetweekly.com/articles/build-automation-with-nuke</link>
            <guid>https://www.dotnetweekly.com/articles/build-automation-with-nuke</guid>
            <pubDate>Thu, 22 Apr 2021 17:37:57 GMT</pubDate>
            <content:encoded><![CDATA[Nuke is an open-source, cross-platform build automation solution for .NET projects. NUKE prides itself on its simplicity and extensibility that makes build automation approachable for everyone.

In this episode,  Matthias Koch joins Rich to give an understanding of what NUKE is and where it fits within the development cycle.

[01:03] - What is NUKE?
[03:00] - Where does NUKE shine?
[06:45] - Setting up a NUKE configuration
[11:50] - Does this ever conflict with MS Build?
[14:44] - Exploring a publish configuration
[20:46] - Where to find Getting Started information?
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Async and Await In C#]]></title>
            <link>https://www.dotnetweekly.com/articles/async-and-await-in-c</link>
            <guid>https://www.dotnetweekly.com/articles/async-and-await-in-c</guid>
            <pubDate>Thu, 22 Apr 2021 17:37:24 GMT</pubDate>
            <content:encoded><![CDATA[Basics of C# async await. In this article, you'll learn what C# async and C# await keywords are and how to use async and await in C# code.
 
Nowadays, Asynchronous programming is very popular with the help of the async and await keywords in C#. When we are dealing with UI, and on button click, we use a long-running method like reading a large file or something else which will take a long time, in that case, the entire application must wait to complete the whole task. In other words, if any process is blocked in a synchronous application, the whole application gets blocked, and our application stops responding until the whole task completes.
Asynchronous programming is very helpful in this condition. By using Asynchronous programming, the Application can continue with the other work that does not depend on the completion of the entire task.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How Blazor Performs Against Other Frameworks]]></title>
            <link>https://www.dotnetweekly.com/articles/how-blazor-performs-against-other-frameworks</link>
            <guid>https://www.dotnetweekly.com/articles/how-blazor-performs-against-other-frameworks</guid>
            <pubDate>Thu, 22 Apr 2021 17:15:12 GMT</pubDate>
            <content:encoded><![CDATA[We’ll use Blazor Server, Blazor WebAssembly and an ASP.NET Core MVC application to compare performance, looking at network activity to measure against the number of HTTP requests and total load time.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Web Performance Recipes With Puppeteer]]></title>
            <link>https://www.dotnetweekly.com/articles/web-performance-recipes-with-puppeteer</link>
            <guid>https://www.dotnetweekly.com/articles/web-performance-recipes-with-puppeteer</guid>
            <pubDate>Thu, 22 Apr 2021 17:11:08 GMT</pubDate>
            <content:encoded><![CDATA[Get a DevTools performance trace for a page load
Get a DevTools trace with screenshots
Get a DevTools trace and extract filmstrip screenshots
Get a DevTools trace for a user interaction
Get Runtime performance metrics
Generate a Lighthouse report
Extract Lighthouse performance metrics
Emulate a slow network
Emulate a slow network and CPU
Test your site renders with JavaScript disabled
Get Navigation Timing API metrics
Measure First Paint and First Contentful Paint
Measure Largest Contentful Paint w/PerformanceObserver
Measure Cumulative Layout Shift w/PerformanceObserver
Measure SPA metrics with Next.js
Get DevTools-specific metrics: Frames Per Second
Measure memory leaks
Override requests with Request Interception
Block third-party domains
Code Coverage for JavaScript and CSS]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Capture emails during development using smtp4dev and UI Test with Selenium]]></title>
            <link>https://www.dotnetweekly.com/articles/capture-emails-during-development-using-smtp4dev-and-ui-test-with-selenium</link>
            <guid>https://www.dotnetweekly.com/articles/capture-emails-during-development-using-smtp4dev-and-ui-test-with-selenium</guid>
            <pubDate>Thu, 22 Apr 2021 17:07:20 GMT</pubDate>
            <content:encoded><![CDATA[If you develop websites for a living, you probably have created a couple of forms that send out emails. You may have created dozens of them by now and your personal inbox is filled with spam from yourself and your peers testing. So much so that you've created automated Outlook rules to read & archive them automatically.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What’s new in dotnet monitor]]></title>
            <link>https://www.dotnetweekly.com/articles/whats-new-in-dotnet-monitor</link>
            <guid>https://www.dotnetweekly.com/articles/whats-new-in-dotnet-monitor</guid>
            <pubDate>Thu, 22 Apr 2021 17:07:00 GMT</pubDate>
            <content:encoded><![CDATA[We’ve previously introduced dotnet monitor as an experimental tool to access diagnostics information in a dotnet process. We’re now pleased to announce dotnet monitor has graduated to a supported tool in the .NET ecosystem. dotnet monitor will be fully supported beginning with our first stable release later this year.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Do Microservices require Containers/Docker/Kubernetes?]]></title>
            <link>https://www.dotnetweekly.com/articles/do-microservices-require-containers-docker-kubernetes</link>
            <guid>https://www.dotnetweekly.com/articles/do-microservices-require-containers-docker-kubernetes</guid>
            <pubDate>Thu, 22 Apr 2021 17:06:37 GMT</pubDate>
            <content:encoded><![CDATA[Containers, Docker, Kubernetes, and Serverless are often used when explaining a Microservices architecture. However, focusing on physical deployment is missing the point of Microservices entirely. Microservices (or any size services) are about logical separation and not about physical deployment. Deployment flexibility is a by-product of having well-defined boundaries for services that are autonomous.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[.NET Core Integration Tests using a Sql Server Database in Docker]]></title>
            <link>https://www.dotnetweekly.com/articles/net-core-integration-tests-using-a-sql-server-database-in-docker</link>
            <guid>https://www.dotnetweekly.com/articles/net-core-integration-tests-using-a-sql-server-database-in-docker</guid>
            <pubDate>Thu, 22 Apr 2021 17:06:13 GMT</pubDate>
            <content:encoded><![CDATA[So I was revamping the tests in the template projects for Wrapt and wanted to try using a real database instead of compromising for an in memory one. There’s a few reasons for this, but most notably is being able to get to your test environment as close to realistic as possible.

Setting things up with a local database isn’t terribly hard but it does require some manual steps when setting things up for the first time and requires a specific local set up. This can be automated to a degree like Jimmy Bogard does in his Contoso repo but I was aiming for something a little different.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploying C# Web Applications with Docker]]></title>
            <link>https://www.dotnetweekly.com/articles/deploying-c-web-applications-with-docker</link>
            <guid>https://www.dotnetweekly.com/articles/deploying-c-web-applications-with-docker</guid>
            <pubDate>Thu, 22 Apr 2021 17:05:47 GMT</pubDate>
            <content:encoded><![CDATA[This article covers

Creating and running a Docker image
Adding an image to a container registry
Pulling an image from a container registry
Accessing the properties of a container]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Signals: .NET 5 based framework for developing enterprise and SaaS applications. ]]></title>
            <link>https://www.dotnetweekly.com/articles/signals-net-5-based-framework-for-developing-enterprise-and-saas-applications</link>
            <guid>https://www.dotnetweekly.com/articles/signals-net-5-based-framework-for-developing-enterprise-and-saas-applications</guid>
            <pubDate>Wed, 21 Apr 2021 09:19:51 GMT</pubDate>
            <content:encoded><![CDATA[Signals is a .NET5 based framework which focuses on increasing the quality and productivity within development teams by providing them with tools, aspects and processes.

Overview can be found on https://signals.emitknowledge.com/

Kickstart
Kick start via Signals Boilerplate on https://github.com/EmitKnowledge/Signals-Boilerplate

High-level aspects
When developing an application, certain aspects are mandatory in the project setup phase that are consuming development teams time and focus.

Dependency Injection
Dependency injection. Signals enables you to use your DI framework of choice with the power of attribute-based injection.

Out of the box Signals offers integration with Autofac, DotNetCore and Simple Injector. Integrating another framework is available through following the convention.

Configuration
Treat configuration files as objects independent of the storage. Signals enables you to create and maintain configuration files. The framework allows you to set different configurations per environment and to select an active environment. All configurations are mapped against objects.

Out of the box Signals has implementation for File and MSSQL configuration providers.

Logging
Signals provides a standardized logging interface that supports integration with existing logging libraries.

Out of the box Signals integrates with NLog. As the framework is extensible by definition, adding an implementation with another logging library is straight forward.

Auditing
In the enterprise world, there is often a need to understand who did what and when. Signals support auditing via integration with Audit.NET and MSSQL database. Extending the auditing aspect is supported like with the rest of the aspects in the framework.

Caching
No matter how fast is your application, it is good to store the most accessed information in the cache. Signals supports in memory caching. Using a different system like Redis can be achieved by extending the caching aspect.

Localization
You never know when you will get a new request to add support for different languages in the application. Signals got this covered for you. Out of the box the framework supports file, MSSQL and in memory localization setup.

Storage
When your application requires storing files, Signals supports upload and encryption of files for file system, Azure Blob storage and MSSQL database. Other storage providers are supported by extension of Signals.

Communication channels
Signals supports distributed processes. The framework supports a request to start from the web application and to finish on the background service. This is achieved with the support of communication channels which by default we support Azure Event Grid, MSMQ, MSSQL and Azure Service Bus.

Authentication and authorization
This aspect enables you to configure authentication for both ASP.NET MVC and ASP.NET Core. Signals support managing authentication, authorization and permissions with ease with attributes and by direct usage of the authentication, authorization and permission managers.

Scheduled tasks
Signals support task scheduling with daily, monthly, pattern-based, time part, weekend, weekly and workday recurrence configuration. Current implementations are through Fluent Scheduler and Hangfire. Can be extended with other libraries as well.

Error handling
Having a centralized mechanism to handle exceptions and retry policies is of great need to prevent information to leak outside the system boundaries and to be able to extract meaningful information from the exceptions and errors. Signals supports this through Polly.NET.

Benchmarking
We are often challenged to improve long-running processes. To be able to achieve better performance, you will need information on how your system behaves and which processes are the bottleneck. The benchmarking aspect will give you the details by allowing you to track processes, chains and checkpoints.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to merge JSON documents in .NET Core and .NET 5?]]></title>
            <link>https://www.dotnetweekly.com/articles/how-to-merge-json-documents-in-net-core-and-net-5</link>
            <guid>https://www.dotnetweekly.com/articles/how-to-merge-json-documents-in-net-core-and-net-5</guid>
            <pubDate>Tue, 20 Apr 2021 09:17:32 GMT</pubDate>
            <content:encoded><![CDATA[Let’s say we have two JSON documents that we would like to merge. How can this be achieved using Newtonsoft.Json and System.Text.Json libraries?]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rendering dynamic content in Blazor Wasm using DynamicComponent]]></title>
            <link>https://www.dotnetweekly.com/articles/rendering-dynamic-content-in-blazor-wasm-using-dynamiccomponent</link>
            <guid>https://www.dotnetweekly.com/articles/rendering-dynamic-content-in-blazor-wasm-using-dynamiccomponent</guid>
            <pubDate>Tue, 20 Apr 2021 05:52:35 GMT</pubDate>
            <content:encoded><![CDATA[In this article, we'll see how to use the new DynamicComponent from .NET 6 to render dynamic content and to avoid tight coupling between page and component.]]></content:encoded>
        </item>
    </channel>
</rss>