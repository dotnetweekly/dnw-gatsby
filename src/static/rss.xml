<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>dotNET Weekly - Week undefined Year undefined</title>
        <link>https://www.dotnetweekly.com/week/undefined/year/undefined?feed=rss</link>
        <description></description>
        <lastBuildDate>Mon, 09 Dec 2019 04:46:13 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <category>Articles</category>
        <category>Libraries-Tools</category>
        <item>
            <title><![CDATA[Making a Better Custom Select Element]]></title>
            <link>https://www.dotnetweekly.com/articles/making-a-better-custom-select-element</link>
            <guid>https://www.dotnetweekly.com/articles/making-a-better-custom-select-element</guid>
            <pubDate>Mon, 09 Dec 2019 04:31:01 GMT</pubDate>
            <content:encoded><![CDATA[In my work as an accessibility consultant, there are some frequent problems I find on people’s websites. One that’s come up a lot recently is that people are making custom select inputs for their forms. I can tell that people are trying to make them accessible, because they’ve added ARIA attributes or visually-hidden instructions for screen reader users. Sometimes they use a plugin which claims to be accessible. And this is great, I love that folks want to do the right thing! But so far I’ve never come across a custom select input which actually meets all of the WCAG AA criteria.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to simulate AutoMapper that works during the build time]]></title>
            <link>https://www.dotnetweekly.com/articles/how-to-simulate-automapper-that-works-during-the-build-time</link>
            <guid>https://www.dotnetweekly.com/articles/how-to-simulate-automapper-that-works-during-the-build-time</guid>
            <pubDate>Mon, 09 Dec 2019 04:29:26 GMT</pubDate>
            <content:encoded><![CDATA[Almost two years ago I created the very first version of MappingGenerator. Since then, I’ve put a lot of work in this project, adding new functions and improving the mapping generation algorithm with 14 releases (43 issues/feature requests closed) in the meantime. With over 5.5k downloads from the marketplace and 380 stars on Github, it looks like there is quite a market demand for this kind of tool (even though my coffee button statistics indicate something different). In the meantime, I got a couple of feature requests to implement some kind of mechanism that allows tracking changes of mapped classes and synchronize the mapping code in response to these changes. I was resisting for some time because it seemed to be a quite complicated problem but after a while, I decided to give it a try and make something that will somehow satisfy all those requirements. In this blog post I’m going to describe how to create a tool for generating code during the build process and how I used it to create auto-synchronizing mapping classes.

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Announcing Entity Framework Core 3.1 and Entity Framework 6.4]]></title>
            <link>https://www.dotnetweekly.com/articles/announcing-entity-framework-core-31-and-entity-framework-64</link>
            <guid>https://www.dotnetweekly.com/articles/announcing-entity-framework-core-31-and-entity-framework-64</guid>
            <pubDate>Mon, 09 Dec 2019 04:26:33 GMT</pubDate>
            <content:encoded><![CDATA[EF Core 3.1 is distributed exclusively as a set of NuGet packages. For example, to add the SQL Server provider to your project, you can use the following command using the dotnet tool:

dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 3.1.0
When upgrading applications that target older versions of ASP.NET Core to 3.1, you may also have to add the EF Core packages as an explicit dependency.

Starting in 3.0 and continuing for 3.1, the dotnet ef command-line tool is no longer included in the .NET Core SDK. Before you can execute EF Core migration or scaffolding commands, you’ll have to install this package as either a global or local tool. To install the final version of our 3.1.0 tool as a global tool, use the following command:

dotnet tool install --global dotnet-ef --version 3.1.0
It’s possible to use this new version of dotnet ef with projects that use older versions of the EF Core runtime. However, older versions of the tool will not work with EF Core 3.1.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ASP.NET Core updates in .NET Core 3.1]]></title>
            <link>https://www.dotnetweekly.com/articles/aspnet-core-updates-in-net-core-31</link>
            <guid>https://www.dotnetweekly.com/articles/aspnet-core-updates-in-net-core-31</guid>
            <pubDate>Mon, 09 Dec 2019 04:25:53 GMT</pubDate>
            <content:encoded><![CDATA[Here’s what’s new in this release for ASP.NET Core:

Partial class support for Razor components
Pass parameters to top-level components
New component tag helper
Prevent default actions for events in Blazor apps
Stop event propagation in Blazor apps
Detailed errors during Blazor app development
Support for shared queues in HttpSysServer
Breaking changes for SameSite cookies]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Using WebAssembly from .NET with Wasmtime]]></title>
            <link>https://www.dotnetweekly.com/articles/using-webassembly-from-net-with-wasmtime</link>
            <guid>https://www.dotnetweekly.com/articles/using-webassembly-from-net-with-wasmtime</guid>
            <pubDate>Mon, 09 Dec 2019 04:22:28 GMT</pubDate>
            <content:encoded><![CDATA[Wasmtime, the WebAssembly runtime from the Bytecode Alliance, recently added an early preview of an API for .NET Core, Microsoft’s free, open-source, and cross-platform application runtime. This API enables developers to programmatically load and execute WebAssembly code directly from their .NET programs.

.NET Core is already a cross-platform runtime, so why should .NET developers pay any attention to WebAssembly?

There are several reasons to be excited about WebAssembly if you’re a .NET developer, such as sharing the same executable code across platforms, being able to securely isolate untrusted code, and having a seamless interop experience with the upcoming WebAssembly interface types proposal.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[.NET Core 2.2 will reach End of Life on December 23, 2019]]></title>
            <link>https://www.dotnetweekly.com/articles/net-core-22-will-reach-end-of-life-on-december-23-2019</link>
            <guid>https://www.dotnetweekly.com/articles/net-core-22-will-reach-end-of-life-on-december-23-2019</guid>
            <pubDate>Mon, 09 Dec 2019 04:22:02 GMT</pubDate>
            <content:encoded><![CDATA[.NET Core 2.2 was released on December 4, 2018. As a non-LTS (“Current”) release, it is supported for three months after the next release. .NET Core 3.0 was released on September 23, 2019. As a result, .NET Core 2.2 is supported until December 23, 2019.

After that time, .NET Core patch updates will no longer include updated packages of container images for .NET Core 2.2. You should plan your upgrade from .NET Core 2.2 now.

.NET Core 3.1 released December 3, 2019 as a Long-term support release. As a result, .NET Core 3.0, released September 23, 2019 is supported until March 23, 2020.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BookFx provides an extremely effective method for creating Excel workbooks of any complexity.]]></title>
            <link>https://www.dotnetweekly.com/articles/bookfx-provides-an-extremely-effective-method-for-creating-excel-workbooks-of-any-complexity</link>
            <guid>https://www.dotnetweekly.com/articles/bookfx-provides-an-extremely-effective-method-for-creating-excel-workbooks-of-any-complexity</guid>
            <pubDate>Mon, 09 Dec 2019 04:21:17 GMT</pubDate>
            <content:encoded><![CDATA[Composing Excel spreadsheets based on a tree of nested components like the HTML DOM.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hacking C#: Programming for the Truly Lazy]]></title>
            <link>https://www.dotnetweekly.com/articles/hacking-c-programming-for-the-truly-lazy</link>
            <guid>https://www.dotnetweekly.com/articles/hacking-c-programming-for-the-truly-lazy</guid>
            <pubDate>Mon, 09 Dec 2019 04:20:50 GMT</pubDate>
            <content:encoded><![CDATA[Welcome to my very first blog entry. Do please wipe your feet on the way in and try not to leave any mess. Beers are in the fridge, help yourselves!

This blog was posted as part of the Third Annual C# Advent. Make sure to check out everyone else's work when you're done here

This is the first in a series of articles I'm planning to write on some of the techniques I've used over the years to accomplish a whole load more in C# with as little effort as I can get away with. I'm very much of the opinion that life is too short to spend writing the same old boilerplate code, and that every problem only ever needs to be solved once. Hopefully, this article series will open your eyes a little to what can be done with a bit of imagination.

A common enough scenario you might encounter is that - given an array - you need to adjust one of its records. If you're following best practice, then you'll be referencing arrays between functions in their most abstract form - the IEnumerable<T> - and if not, why not?

If you've got an array of items referenced as such, then it's trivial to update a specific item, you'd just do it like this:]]></content:encoded>
        </item>
    </channel>
</rss>